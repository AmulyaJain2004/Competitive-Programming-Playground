#include <bits/stdc++.h>using namespace std; int main() {    int t;    cin >> t;    while (t--) {        int n, m;        cin >> n >> m;        string x;        cin >> x;        string s;        cin >> s;        int count = 0;        // Optimised is KMP algorithm approach which will be done later         // My original approach        // passes existing test cases but fails on some hidden cases        // bool found = false;        // if (x.find(s) != string::npos) {        //     found = true;        // }        // else {        //     while(x.size() <= s.size() || x.find(s) == string::npos) {        //         x += x;        //         count++;        //         if (x.find(s) != string::npos) {        //             found = true;        //             break;        //         }        //     }        // }        // if (found){        //     cout << count << endl;        // }        // else {        //     cout << -1 << endl;        // }         // Normal approach        // Increasing x until it is same as size as s        while (x.size() < s.size()) {            x += x;            count++;        }        // check for substring once        if (x.find(s) != string::npos) {            cout << count << "\n";            continue;        }        // increment one last time to check again in case any edge case        x += x;        count ++;         if (x.find(s) != string::npos) {            cout << count << endl;        }        else {            cout << -1 << endl;        }    }        return 0;}